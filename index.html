<head>
    <title>Team Tuna - Rust</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            color: #333;
        }

        h1 {
            color: #2c3e50;
            font-size: 28px;
            margin-top: 20px;
        }

        h2 {
            font-size: 24px;
            margin-top: 10px;
            color: #34495e;
        }

        p {
            font-size: 120%;
            line-height: 1.6;
            margin: 10px 0;
            padding: 0 20px;
        }

        a {
            color: #2980b9;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background-color: #3498db;
            color: white;
        }

        td {
            background-color: #ecf0f1;
        }

        tr:nth-child(even) td {
            background-color: #f9f9f9;
        }

        .container {
            width: 80%;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .intro {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .link-list {
            padding: 0;
            list-style-type: none;
            margin: 10px 0;
        }

        .link-list li {
            margin-bottom: 8px;
        }

        .footer {
            text-align: center;
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 40px;
        }

        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .row {
            display: flex;
        }

        .column {
            flex: 40%;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Team Tuna - Rust</h1>
        
        <h2>Description</h2>
        <p>Rust is a modern, high-performance, systems programming language that focuses on maximizing program performance with strong type safety and concurrency features. Rust enforces memory safety like many other modern PL's, but does so without a "garbage collector", instead opting to use a "borrow checker" and an ownership model that tracks the lifetime of the memory object during compile time, making sure there are no null pointer dereferences, use-after-free bugs, and data races. For example, below is an example of the ownership model:</p>
        <img src="rustownership.PNG" width="40%" height="auto" class="center" />
        <p>The output (notice how awesome the Rust debugger is): </p>
        <img src="rustownershipoutput.PNG" width="75%" height="auto" class="center" />
        <p>Rust also does not have null values or pointers, instead featuring an "Option" module with "Some" value or "None":</p>
        <img src="rustoption.PNG" width="40%" height="auto" class="center" />
        <p>Rust also features strong package managers, is safe and reliable, and has a modern, clean syntax that is easy to read and understand. Rust's syntax takes inspiration from multiple languages like C, Java, and Python.</p>
        <p>Rust handles errors with with a "Result" module that transforms functions to return an enum containing either Ok(x), resembling a good value, or Err(x), resembling an error:</p>
        <img src="rusterrorhandle.PNG" width="50%" height="auto" class="center" />
        <p>Rust was influenced by ideas from functional programming, meaning that it supports object immutability, higher-order functions, and pattern matching.</p>
        <div class="row">
            <img src="rustimmutable.PNG" width="40%" height="auto" class="column" /><img src="rusthighorder.PNG" width="40%" height="auto" class="column" />
        </div>
        <p>Rust also supports multiple object-oriented principles, like encapsulation through structs and impl (implements), polymorphism and inheritance via traits, and more, even though Rust is not an object-oriented language.</p>
        <p>Rust features a construct known as a "macro". Macros, in simple terms, are code that generates other code (metaprogramming). Macros, unlike functions, work at the syntax level before compilation. Because of this, code is generated during compile time, allowing errors to be caught during compilation, and creates no runtime overhead, allowing the program to run faster. Macros are also more flexible than functions since they can take a variable number of arguments (see println!), implement a trait on a type (similar to Java Intergaces), or use custom syntax. They are denoted by the exclamation mark after the macro's name and before the parantheses.</p>
        <p>Rust is very popular for systems programming, like building computer system software, web servers, game engines, and other services that rely on performance-critical code. For example, here is an example of a speed comparison between multiple languages solving the same problem:</p>
        <img src="languagecomparison.jpg" width="50%" height="auto" class="center">
        <h2>History</h2>
        <p>Rust was developed by Graydon Hoare, a Mozilla employee, in 2006 as a personal project. His goal for this project was to design a systems programming language that avoided common errors found in C++, like segmentation faults and undefined behavior. In 2009, Mozilla officially sponsored Graydon's project. Mozilla's goal with the project was to create a language that would power the next generation of high-performance applications. After many years of development and testing, Mozilla released the first stable version of Rust in 2015.</p>
        <p>Timeline:</p>
        <ol>
            <li>2010: Rust's ownership system was developed, although not fully completed since Rust still used a garbage collector.</li>
            <li>2011: Rust's syntax and semantics were (pretty much) fully developed and tested, and the language's backend was switched to LLVM for compilation. LLVM is used by popular languages like C, C++, Swift, and Go.</li>
            <li>2012: The first public non-stable release, Rust 0.1, was released in January.</li>
            <li>2013: Rust's ownership model made major improvments, which led to the removal of the garbage collector.</li>
            <li>2013: Rust removed pure functions (which where declared with "pure") and specialized syntax support for channels and various pointer types to simplify the language.</li>
            <li>2013: Graydon Hoare stepped down from the Rust development team.</li>
            <li>2015: Rust 1.0 officially launched as the first stable public release.</li>
            <li>2016: Rust's real-world usage was demonstrated in the Servo project, Mozilla's experimental web browser.</li>
            <li>2020: The "Rust for Linux" project began, whose goal is to add Rust as a programming language that can be used in the Linux kernel.</li>
            <li>2023: The first drivers written in Rust were accepted by Linus Torvalds, leader of the Linux kernel project.</li>
        </ol>
        <p>Rust is currently being rapidly adopted by a multitude of companies due to its strong performance and capabilities.</p>
        <p>Fun Fact: Amazon developers cited that Rust uses half as much electricity as similar code written in Java, only being behind C in efficiency.</p> 

        <h2>Links</h2>
        <ul class="link-list">
            <li><a href="https://doc.rust-lang.org/reference/">Rust Specification</a></li>
            <li><a href="https://doc.rust-lang.org/beta/">Rust Documentation</a></li>
            <li><a href="https://www.rust-lang.org/learn">Rust Tutorials</a></li>
        </ul>

        <div class="intro">
            <h2>Translators & Instructions</h2>
            <h3>rustc / cargo</h3>
            <ol>
                <li>Go to <a href="https://www.rust-lang.org/tools/install">rust-lang.org</a> and install rustup.</li>
                <li>If you're on Windows or Mac, there's an .exe file to install.</li>
                <li>If on Windows Sybsystem for Linux, run the following command: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</li>
                <li>If on Linux, run the following command in terminal: curl https://sh.rustup.rs -sSf | sh</li>
                <li>Once everything is installed, to start a new package, run "cargo new" followed by a name for the package. This creates a working directory for you to work in.</li>
                <li>If the cargo command does not work, run "sudo apt install build-essential". This is a C linker that is necessary for cargo.</li>
                <li>Then, begin working on a rust program in the "src" directory.</li>
                <li>Once done with your program, from the "src" directory, run "cargo build" to compile the project. If any errors show up, fix them.</li>
                <li>Then, run "cargo run" to run the program.</li>
            </ol>
            <p></p>

            <h2>Introductory Programs</h2>
            <br></br>

            <h3>Hello World Function Call</h3>
            <img src="rusthelloworld.PNG" class="center">
            <br></br>
            <img src="rusthelloworldoutput.PNG" class="center" width="50%" height="auto">

            <h3>Iterate through a 2 dimensional array</h3>
            <img src="rust2darray.PNG" class="center" width="40%" height="auto">
            <br></br>
            <img src="rust2darrayoutput.PNG" class="center" width="50%" height="auto">
            
            <h3>Fibonacci Sequence</h3>
            <img src="rustfibonacci.PNG" class="center" width="40%" height="auto">
            <br></br>
            <img src="rustfibonaccioutput.PNG" class="center" width="50%" height="auto">
            
            <h3>Threads in Rust</h3>
            <img src="rustthreads.PNG" class="center" width="50%" height="auto">
            <br></br>
            <img src="rustthreadsoutput.PNG" class="center" width="50%" height="auto">

            <h2>Complex Program</h2>
            <a href="main.rs">Code for Complex Program</a>

            <h2>Comparison To Similar Languages</h2>
            <table border="1">
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Rust</th>
                        <th>C</th>
                        <th>C++</th>
                        <th>Java</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Paradigms</td>
                        <td>Systems programming, functional, imperative</td>
                        <td>Procedural, imperative</td>
                        <td>Multi-paradigm: procedural, object-oriented, generic</td>
                        <td>Object-oriented, some functional features</td>
                    </tr>
                    <tr>
                        <td>Use Cases</td>
                        <td>Systems programming, web servers, CLI tools, game engines, blockchain</td>
                        <td>OS development, embedded systems, hardware programming</td>
                        <td>Game engines, real-time systems, performance-critical applications</td>
                        <td>Enterprise software, Android apps, web servers</td>
                    </tr>
                    <tr>
                        <td>Memory Management</td>
                        <td>Ownership with borrowing/lifetimes, no garbage collector</td>
                        <td>Manual memory management</td>
                        <td>Manual (pointers) and automatic (smart pointers in modern C++)</td>
                        <td>Automatic garbage collection via JVM</td>
                    </tr>
                    <tr>
                        <td>Type System</td>
                        <td>Strong, static, expressive (generics, traits, lifetimes)</td>
                        <td>Weak, static</td>
                        <td>Strong, static (templates, polymorphism, inheritance)</td>
                        <td>Strong, static (generics with type erasure)</td>
                    </tr>
                    <tr>
                        <td>Concurrency</td>
                        <td>Safe concurrency without data races, enforced at compile time</td>
                        <td>Libraries like pthreads, prone to data races</td>
                        <td>Libraries available, but thread safety depends on the programmer</td>
                        <td>Built-in threading model, runtime safety with `synchronized`</td>
                    </tr>
                    <tr>
                        <td>Syntax Complexity</td>
                        <td>Modern, expressive, concise but strict</td>
                        <td>Simple, minimal</td>
                        <td>Complex due to advanced features like templates and manual memory management</td>
                        <td>Simple but verbose, designed for readability</td>
                    </tr>
                    <tr>
                        <td>Compiled or Interpreted</td>
                        <td>Compiled to native machine code</td>
                        <td>Compiled to native machine code</td>
                        <td>Compiled to native machine code</td>
                        <td>Compiled to bytecode and interpreted/compiled by JVM</td>
                    </tr>
                    <tr>
                        <td>Performance</td>
                        <td>High, comparable to C/C++, optimized with zero-cost abstractions</td>
                        <td>High, close to the hardware</td>
                        <td>High, close to C but can be slower due to abstraction overhead</td>
                        <td>Slower than Rust/C/C++ due to JVM overhead</td>
                    </tr>
                    <tr>
                        <td>Learning Curve</td>
                        <td>Steep (ownership model, strict compiler rules)</td>
                        <td>Moderate (simpler but requires understanding of manual memory management)</td>
                        <td>Steep (complex syntax, templates, and object-oriented programming)</td>
                        <td>Moderate (garbage collection and extensive documentation help beginners)</td>
                    </tr>
                    <tr>
                        <td>Platform Independence</td>
                        <td>Cross-compilation supported but output binaries are platform-specific</td>
                        <td>Platform-specific binaries</td>
                        <td>Cross-compilation supported but output binaries are platform-specific</td>
                        <td>Fully portable; "write once, run anywhere" via JVM</td>
                    </tr>
                    <tr>
                        <td>Unique Strengths</td>
                        <td>Ownership for memory safety, zero-cost abstractions, fearless concurrency</td>
                        <td>Simple and fast for low-level hardware programming</td>
                        <td>Combines high-level abstraction with low-level control, wide community support</td>
                        <td>Rich ecosystem for enterprise development, platform independence, automatic garbage collection</td>
                    </tr>
                </tbody>
            </table>            
        </div>

        <div class="footer">
            <p>&copy; 2024 Team Tuna. All Rights Reserved.</p>
        </div>
    </div>
</body>
